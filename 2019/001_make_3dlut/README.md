# 3DLUT を Python でサクッと作る

## 1. 目的

3DLUTデータの作り方を簡単に解説する。例として HDR(※) のデータを SDR に変換する 3DLUT を作成する。

なお、本記事は 3DLUT の作り方に特化した記事としたため基礎的な情報は省略している。それらの基礎的な知識は [富士フィルムさんの資料](https://t.co/526Cc4wFYK)[1]を参照して欲しい。

※ここで言う **HDR のデータ** とは 伝達関数(Transfer Function)、色域(Gamut)、白色点(White Point) がそれぞれ SMPTE ST2084, BT2020, D65 であるデータを意味する。

## 2. 結論

作成した 3DLUT を検証用テストパターンに適用した結果を示しておく。以下の図1は 3DLUT を使って HDR のテストパターンを SDR に変換したものである。なお、3DLUT の適用には Davinci Resolve を使用した。

| ソース画像 | 3DLUT を使い変換した結果 |
|:---------:|:---------:|
|![src](./blog_figures/src.png)|![result](./blog_figures/using_3dlut.png)|

右上のカラーチェッカーおよび下部のグレースケールを見ると、正しそうなことが分かる。本来なら目視による評価だけでなく定量的に正しいか判断するのだが、記事が長くなるので目視確認のみとする。

## 3. 3DLUT の作り方

### 3.0. おおまかな手順

おおまかな手順を以下に示す。

1. 格子点数の決定
2. 格子点に相当する R, G, B データを作成
3. R, G, B データに対して所望の処理を実行
4. 変換後の R, G, B 値を LUTデータとしてテキストファイルに保存

### 3.1 格子点数の決定

3DLUT の格子点数は 17x17x17x, 33x33x33, 65x65x65 など **2のべき乗+1** の値を使うのが一般的である。もちろん理論上はこれ以外の格子点数も使用可能だが、映像制作ツールが **2のべき乗+1** 以外の格子点数のデータを読み込めるかは不明である。特に理由が無ければ上記の格子点を使うことを推奨する。

なお、当然のことだが格子点数を増やすと精度は良くなるがパフォーマンスは悪くなる。今回はパフォーマンスは気にする必要が無いので精度を重視して 65x65x65 で作成することにする。

### 3.2. 格子点に相当する R, G, B データを作成

3DLUT は「ある画素の色(R1, G1, B1)を別の色(R2, G2, B2)」 に変換する機能をもったテーブルである[1]。全ての色の組み合わせをテーブルとして持つとメモリが爆発するので、「ある画素の色」の代表値として 65x65x65 の格子点を準備する。この格子点は R, G, B の値が等間隔に並ぶように作れば良い。

筆者が Python で作った例を以下に示す。なお、ここでは説明たために格子点数を 65x65x65 ではなく 3x3x3 としている。

```python
$ python
>>> import make_3dlut
>>> make_3dlut.make_3dlut_grid(grid_num=3)
array([[[ 0. ,  0. ,  0. ],
        [ 0.5,  0. ,  0. ],
        [ 1. ,  0. ,  0. ],
        [ 0. ,  0.5,  0. ],
        [ 0.5,  0.5,  0. ],
        [ 1. ,  0.5,  0. ],
        [ 0. ,  1. ,  0. ],
        [ 0.5,  1. ,  0. ],
        [ 1. ,  1. ,  0. ],
        [ 0. ,  0. ,  0.5],
        [ 0.5,  0. ,  0.5],
        [ 1. ,  0. ,  0.5],
        [ 0. ,  0.5,  0.5],
        [ 0.5,  0.5,  0.5],
        [ 1. ,  0.5,  0.5],
        [ 0. ,  1. ,  0.5],
        [ 0.5,  1. ,  0.5],
        [ 1. ,  1. ,  0.5],
        [ 0. ,  0. ,  1. ],
        [ 0.5,  0. ,  1. ],
        [ 1. ,  0. ,  1. ],
        [ 0. ,  0.5,  1. ],
        [ 0.5,  0.5,  1. ],
        [ 1. ,  0.5,  1. ],
        [ 0. ,  1. ,  1. ],
        [ 0.5,  1. ,  1. ],
        [ 1. ,  1. ,  1. ]]])
```

上記の例を見れば分かる通り、R --> G --> B の順にデータが均等に増加している。3DLUTを作成する際は、このようにして「ある画素の色」の代表値を準備する。

### 3.3. R, G, B データに対して所望の処理を実行

格子点の代表値のデータが準備できたら、R, G, B データに対して所望の処理(今回の例だと Gamma2.4-BT709-D65 への変換が該当)を実行する。

今回のサンプルでは以下の書き方となる。

```python
    # R, G, B の grid point データを準備
    x = make_3dlut_grid(grid_num=grid_num)

    # linear に戻す
    linear_luminance = eotf_ST2084(x)

    # 単位が輝度(0～10000 nits)になっているので
    # 一般的に使われる 1.0 が 100 nits のスケールに変換
    linear = linear_luminance / NOMINAL_WHITE_LUMINANCE

    # 色域を BT.2020 --> BT.709 に変換
    linear_bt709 = RGB_to_RGB(RGB=linear,
                              input_colourspace=BT2020_COLOURSPACE,
                              output_colourspace=BT709_COLOURSPACE)

    # BT.709 の範囲外の値(linear < 0.0 と linear > 1.0 の領域)をクリップ
    linear_bt709 = np.clip(linear_bt709, 0.0, 1.0)

    # BT.709 のガンマ(OETF)をかける
    non_linear_bt709 = linear_bt709 ** (1 / 2.4)
```

### 3.4. 変換後の R, G, B 値を LUTデータとしてテキストファイルに保存

自作のライブラリを使って、Adobe の Cube 形式でファイルに保存する。

```python
    # 自作の LUTライブラリのクソ仕様のため shape を変換する
    lut_for_save = non_linear_bt709.reshape((grid_num ** 3, 3))

    # .cube の形式で保存
    lut_fname = "./st2084_bt2020_to_gamma2.4_bt709.cube"
    lut.save_3dlut(
        lut=lut_for_save, grid_num=grid_num, filename=lut_fname)
```

Cube 形式のファイルの中身は以下である。

```text
# This 3DLUT data was created by TY-LUT creation tool
TITLE "cube_test"
DOMAIN_MIN 0.0 0.0 0.0
DOMAIN_MAX 1.0 1.0 1.0
LUT_3D_SIZE 65

0.0000000000e+00 0.0000000000e+00 0.0000000000e+00
2.0516382228e-02 0.0000000000e+00 0.0000000000e+00
3.6632494837e-02 0.0000000000e+00 0.0000000000e+00
5.2843508737e-02 0.0000000000e+00 0.0000000000e+00
6.9644134923e-02 0.0000000000e+00 0.0000000000e+00
8.7242266423e-02 0.0000000000e+00 0.0000000000e+00
1.0576292796e-01 0.0000000000e+00 0.0000000000e+00
1.2529901435e-01 0.0000000000e+00 0.0000000000e+00

(中略)

0.0000000000e+00 1.0000000000e+00 1.0000000000e+00
1.0000000000e+00 1.0000000000e+00 1.0000000000e+00
1.0000000000e+00 1.0000000000e+00 1.0000000000e+00
1.0000000000e+00 1.0000000000e+00 1.0000000000e+00
1.0000000000e+00 1.0000000000e+00 1.0000000000e+00
1.0000000000e+00 1.0000000000e+00 1.0000000000e+00
1.0000000000e+00 1.0000000000e+00 1.0000000000e+00
1.0000000000e+00 1.0000000000e+00 1.0000000000e+00
```

## 4. おことわり

今回作成した 3DLUT は Tone Mapping や Gamut Mapping などの最適化処理は一切実施していない。単純な数値変換を行っただけである。そのため、実コンテンツに対して ST2084-BT2020-D65 to  Gamma2.4-BT709-D65 変換するのには全く適さない。あくまでも 3DLUT の一例として捉えて欲しい。

## 5. 参考資料

[1] FUJIFILM, "3DLUT作成のサンプルコードの作成", http://fujifilm.jp/business/broadcastcinema/solution/color_management/is-mini/promotion/pack/pdf/news/20150122_jppa.pdf (2019/08/12 リンク切れを確認。Internet Archive → https://t.co/526Cc4wFYK)